<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AI Utils - Complete AI Toolkit for Building AI Agents</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="docs/styles/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AI Utils - Complete AI Toolkit for Building AI Agents</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/your-username/ai-utils" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ai-utils---complete-ai-toolkit-for-building-ai-agents"><a class="header" href="#ai-utils---complete-ai-toolkit-for-building-ai-agents">AI Utils - Complete AI Toolkit for Building AI Agents</a></h1>
<p>AI Utils is a comprehensive Rust library designed to provide all the essential tools needed to build sophisticated AI agents. It integrates multiple AI services and utilities into a unified, async-first API that makes building AI applications simple and efficient.</p>
<h2 id="-key-features"><a class="header" href="#-key-features">üöÄ Key Features</a></h2>
<ul>
<li><strong>OpenAI Integration</strong>: Complete support for chat completions, embeddings, image generation, and audio transcription</li>
<li><strong>Vector Database</strong>: Seamless integration with Qdrant for vector storage and similarity search</li>
<li><strong>Text Processing</strong>: Advanced text splitting and tokenization with configurable chunking strategies</li>
<li><strong>Monitoring</strong>: Built-in Langfuse integration for comprehensive AI application monitoring</li>
<li><strong>Async-First</strong>: Built on Tokio for high-performance concurrent operations</li>
<li><strong>Type Safety</strong>: Full Rust type safety with comprehensive error handling</li>
</ul>
<h2 id="-use-cases"><a class="header" href="#-use-cases">üéØ Use Cases</a></h2>
<ul>
<li><strong>Chat Bots</strong>: Build conversational AI agents with memory and context</li>
<li><strong>Document Q&amp;A</strong>: Create systems that can answer questions from large document collections</li>
<li><strong>Image Analysis</strong>: Process and analyze images with multimodal AI capabilities</li>
<li><strong>Vector Search</strong>: Implement semantic search across text, images, and other data</li>
<li><strong>AI Monitoring</strong>: Track and analyze AI application performance and usage</li>
</ul>
<h2 id="-quick-installation"><a class="header" href="#-quick-installation">üì¶ Quick Installation</a></h2>
<pre><code class="language-bash"># Add to your Cargo.toml
[dependencies]
ai_utils = "0.1.0"
</code></pre>
<h2 id="-environment-setup"><a class="header" href="#-environment-setup">üîß Environment Setup</a></h2>
<pre><code class="language-bash"># Required environment variables
export OPENAI_API_KEY="your-openai-api-key"
export QDRANT_URL="your-qdrant-url"
export QDRANT_API_KEY="your-qdrant-api-key"
export LANGFUSE_PUBLIC_KEY="your-langfuse-public-key"
export LANGFUSE_SECRET_KEY="your-langfuse-secret-key"
</code></pre>
<h2 id="-quick-start"><a class="header" href="#-quick-start">üöÄ Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust">use ai_utils::{openai::OpenAIService, text_splitter::TextSplitter};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize services
    let openai = OpenAIService::new();
    let splitter = TextSplitter::new(None);
    
    // Process text and get embeddings
    let text = "Your document content here...";
    let chunks = splitter.split(text, 1000)?;
    
    // Generate embeddings
    let embeddings = openai.embed(chunks[0].content.clone()).await?;
    
    println!("Generated {} embeddings", embeddings.len());
    Ok(())
}</code></pre></pre>
<h2 id="-whats-next"><a class="header" href="#-whats-next">üìö What's Next?</a></h2>
<ul>
<li><a href="getting-started/installation.html">Installation Guide</a> - Set up your development environment</li>
<li><a href="getting-started/quick-start.html">Quick Start</a> - Build your first AI agent</li>
<li><a href="getting-started/configuration.html">Configuration</a> - Learn about advanced configuration options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide will help you set up AI Utils in your Rust project.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust 1.70+ (latest stable recommended)</li>
<li>Cargo package manager</li>
<li>API keys for external services</li>
</ul>
<h2 id="adding-to-your-project"><a class="header" href="#adding-to-your-project">Adding to Your Project</a></h2>
<h3 id="1-add-dependency"><a class="header" href="#1-add-dependency">1. Add Dependency</a></h3>
<p>Add AI Utils to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ai_utils = "0.1.0"
tokio = { version = "1.45.1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
</code></pre>
<h3 id="2-install-mdbook-for-documentation"><a class="header" href="#2-install-mdbook-for-documentation">2. Install mdBook (for documentation)</a></h3>
<pre><code class="language-bash">cargo install mdbook
</code></pre>
<h2 id="environment-configuration"><a class="header" href="#environment-configuration">Environment Configuration</a></h2>
<h3 id="required-environment-variables"><a class="header" href="#required-environment-variables">Required Environment Variables</a></h3>
<p>Create a <code>.env</code> file in your project root:</p>
<pre><code class="language-bash"># OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key

# Qdrant Vector Database
QDRANT_URL=https://your-qdrant-instance.com
QDRANT_API_KEY=your-qdrant-api-key

# Langfuse Monitoring (Optional)
LANGFUSE_PUBLIC_KEY=your-langfuse-public-key
LANGFUSE_SECRET_KEY=your-langfuse-secret-key
</code></pre>
<h3 id="getting-api-keys"><a class="header" href="#getting-api-keys">Getting API Keys</a></h3>
<h4 id="openai-api-key"><a class="header" href="#openai-api-key">OpenAI API Key</a></h4>
<ol>
<li>Visit <a href="https://platform.openai.com/">OpenAI Platform</a></li>
<li>Create an account or sign in</li>
<li>Navigate to API Keys section</li>
<li>Create a new API key</li>
<li>Copy the key to your <code>.env</code> file</li>
</ol>
<h4 id="qdrant-setup"><a class="header" href="#qdrant-setup">Qdrant Setup</a></h4>
<ol>
<li><strong>Cloud Option</strong>: Sign up at <a href="https://cloud.qdrant.io/">Qdrant Cloud</a></li>
<li><strong>Self-hosted</strong>: Follow <a href="https://qdrant.tech/documentation/guides/installation/">Qdrant installation guide</a></li>
<li>Get your API key and endpoint URL</li>
</ol>
<h4 id="langfuse-optional"><a class="header" href="#langfuse-optional">Langfuse (Optional)</a></h4>
<ol>
<li>Visit <a href="https://langfuse.com/">Langfuse</a></li>
<li>Create an account</li>
<li>Get your public and secret keys from the dashboard</li>
</ol>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Test your installation with a simple example:</p>
<pre><pre class="playground"><code class="language-rust">use ai_utils::openai::OpenAIService;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    dotenv::dotenv().ok();
    
    let openai = OpenAIService::new();
    let embeddings = openai.embed("Hello, world!".to_string()).await?;
    
    println!("Successfully generated {} embeddings", embeddings.len());
    Ok(())
}</code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="getting-started/quick-start.html">Quick Start Guide</a> - Build your first AI agent</li>
<li><a href="getting-started/configuration.html">Configuration</a> - Learn about advanced configuration options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with AI Utils in minutes. This guide will walk you through building a simple AI agent that can process text and answer questions.</p>
<h2 id="basic-chat-bot"><a class="header" href="#basic-chat-bot">Basic Chat Bot</a></h2>
<p>Let's create a simple chat bot that can maintain conversation context:</p>
<pre><pre class="playground"><code class="language-rust">use ai_utils::{
    openai::{OpenAIService, OpenAIMessage, OpenAIModel},
    text_splitter::TextSplitter,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    dotenv::dotenv().ok();
    
    // Initialize services
    let openai = OpenAIService::new();
    let splitter = TextSplitter::new(None);
    
    // System prompt to define the bot's behavior
    let system_message = OpenAIMessage {
        role: "system".to_string(),
        content: "You are a helpful AI assistant. Provide clear, concise answers.".to_string(),
        name: None,
    };
    
    // User message
    let user_message = OpenAIMessage {
        role: "user".to_string(),
        content: "What is the capital of France?".to_string(),
        name: None,
    };
    
    // Create conversation
    let messages = vec![system_message, user_message];
    
    // Get response
    let response = openai.completion(messages, OpenAIModel::GPT35Turbo).await?;
    
    if let Some(choice) = response.choices.first() {
        println!("AI: {}", choice.message.content);
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="document-qa-system"><a class="header" href="#document-qa-system">Document Q&amp;A System</a></h2>
<p>Create a system that can answer questions about documents:</p>
<pre><pre class="playground"><code class="language-rust">use ai_utils::{
    openai::{OpenAIService, OpenAIMessage, OpenAIModel},
    text_splitter::TextSplitter,
    qdrant::QdrantService,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    dotenv::dotenv().ok();
    
    let openai = OpenAIService::new();
    let splitter = TextSplitter::new(None);
    let qdrant = QdrantService::new().await?;
    
    // Sample document
    let document = r#"
    Artificial Intelligence (AI) is a branch of computer science that aims to create 
    intelligent machines that work and react like humans. Some of the activities 
    computers with artificial intelligence are designed for include speech recognition, 
    learning, planning, and problem solving.
    "#;
    
    // Split document into chunks
    let chunks = splitter.split(document, 1000)?;
    
    // Create collection for document chunks
    let collection_name = "documents";
    qdrant.create_collection(collection_name, 1536).await?;
    
    // Process each chunk
    for (i, chunk) in chunks.iter().enumerate() {
        // Generate embeddings
        let embeddings = openai.embed(chunk.content.clone()).await?;
        
        // Store in vector database
        qdrant.upsert_points(
            collection_name,
            &amp;[i.to_string()],
            &amp;[embeddings],
            &amp;[chunk.content.clone()],
        ).await?;
    }
    
    // Query the system
    let question = "What is artificial intelligence?";
    let question_embeddings = openai.embed(question.to_string()).await?;
    
    // Search for relevant chunks
    let search_results = qdrant.search_points(
        collection_name,
        &amp;question_embeddings,
        3,
    ).await?;
    
    // Build context from search results
    let context: String = search_results
        .iter()
        .map(|result| result.payload.get("text").unwrap_or(&amp;"".to_string()))
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .join("\n\n");
    
    // Generate answer
    let messages = vec![
        OpenAIMessage {
            role: "system".to_string(),
            content: format!(
                "Answer the question based on the following context:\n\n{}",
                context
            ),
            name: None,
        },
        OpenAIMessage {
            role: "user".to_string(),
            content: question.to_string(),
            name: None,
        },
    ];
    
    let response = openai.completion(messages, OpenAIModel::GPT35Turbo).await?;
    
    if let Some(choice) = response.choices.first() {
        println!("Question: {}", question);
        println!("Answer: {}", choice.message.content);
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="image-analysis"><a class="header" href="#image-analysis">Image Analysis</a></h2>
<p>Process and analyze images with multimodal capabilities:</p>
<pre><pre class="playground"><code class="language-rust">use ai_utils::openai::{OpenAIService, OpenAIMessage, OpenAIImageMessage, OpenAIModel};
use std::fs;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    dotenv::dotenv().ok();
    
    let openai = OpenAIService::new();
    
    // Read image file
    let image_data = fs::read("path/to/your/image.jpg")?;
    let base64_image = base64::encode(&amp;image_data);
    let image_url = format!("data:image/jpeg;base64,{}", base64_image);
    
    // Create image message
    let image_message = OpenAIImageMessage {
        role: "user".to_string(),
        content: vec![image_url],
        name: None,
    };
    
    // Text question about the image
    let text_message = OpenAIMessage {
        role: "user".to_string(),
        content: "What do you see in this image?".to_string(),
        name: None,
    };
    
    // Get multimodal response
    let response = openai.completion_image(
        vec![text_message],
        vec![image_message],
        OpenAIModel::GPT4Vision,
    ).await?;
    
    if let Some(choice) = response.choices.first() {
        println!("Image Analysis: {}", choice.message.content);
    }
    
    Ok(())
}</code></pre></pre>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="1-service-initialization"><a class="header" href="#1-service-initialization">1. Service Initialization</a></h3>
<p>All services are initialized with environment variables:</p>
<ul>
<li><code>OpenAIService::new()</code> - Uses <code>OPENAI_API_KEY</code></li>
<li><code>QdrantService::new()</code> - Uses <code>QDRANT_URL</code> and <code>QDRANT_API_KEY</code></li>
</ul>
<h3 id="2-async-operations"><a class="header" href="#2-async-operations">2. Async Operations</a></h3>
<p>All operations are async and should be awaited:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = service.operation().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="3-error-handling"><a class="header" href="#3-error-handling">3. Error Handling</a></h3>
<p>Use the <code>?</code> operator for error propagation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let response = openai.completion(messages, model).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="getting-started/../getting-started/configuration.html">Configuration</a> - Learn about advanced configuration options</li>
<li><a href="getting-started/../getting-started/installation.html">Installation</a> - Set up your development environment</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>This guide covers all configuration options for AI Utils, including environment variables, service settings, and performance tuning.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>AI Utils uses environment variables for configuration. Create a <code>.env</code> file in your project root:</p>
<pre><code class="language-bash"># OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key

# Qdrant Vector Database
QDRANT_URL=https://your-qdrant-instance.com
QDRANT_API_KEY=your-qdrant-api-key

# Langfuse Monitoring (Optional)
LANGFUSE_PUBLIC_KEY=your-langfuse-public-key
LANGFUSE_SECRET_KEY=your-langfuse-secret-key

# Application Settings
RUST_LOG=info
RUST_BACKTRACE=1
</code></pre>
<h2 id="service-configuration"><a class="header" href="#service-configuration">Service Configuration</a></h2>
<h3 id="openai-service"><a class="header" href="#openai-service">OpenAI Service</a></h3>
<p>The OpenAI service is configured automatically from environment variables:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ai_utils::openai::OpenAIService;

// Automatically reads OPENAI_API_KEY from environment
let openai = OpenAIService::new();
<span class="boring">}</span></code></pre></pre>
<p><strong>Available Models:</strong></p>
<ul>
<li><code>GPT35Turbo</code> - Fast, cost-effective</li>
<li><code>GPT4</code> - More capable, better reasoning</li>
<li><code>GPT4Vision</code> - Multimodal (text + image)</li>
</ul>
<h3 id="qdrant-service"><a class="header" href="#qdrant-service">Qdrant Service</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ai_utils::qdrant::QdrantService;

// Automatically reads QDRANT_URL and QDRANT_API_KEY
let qdrant = QdrantService::new().await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Configuration Options:</strong></p>
<ul>
<li><code>QDRANT_URL</code> - Server endpoint</li>
<li><code>QDRANT_API_KEY</code> - Authentication key</li>
<li>Connection timeout (configurable)</li>
<li>Retry policies</li>
</ul>
<h3 id="text-splitter"><a class="header" href="#text-splitter">Text Splitter</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ai_utils::text_splitter::TextSplitter;

// Default configuration
let splitter = TextSplitter::new(None);

// Custom configuration
let config = TextSplitterConfig {
    chunk_size: 1000,
    chunk_overlap: 200,
    separator: "\n\n".to_string(),
};
let splitter = TextSplitter::new(Some(config));
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-configuration"><a class="header" href="#performance-configuration">Performance Configuration</a></h2>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure HTTP client for better performance
use reqwest::Client;

let client = Client::builder()
    .pool_max_idle_per_host(10)
    .timeout(std::time::Duration::from_secs(30))
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure batch sizes for optimal performance
const BATCH_SIZE: usize = 100; // Embeddings
const VECTOR_BATCH_SIZE: usize = 1000; // Vector operations
<span class="boring">}</span></code></pre></pre>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::sync::Mutex;

struct Cache {
    embeddings: Mutex&lt;HashMap&lt;String, Vec&lt;f32&gt;&gt;&gt;,
    responses: Mutex&lt;HashMap&lt;String, String&gt;&gt;,
}

impl Cache {
    pub fn new() -&gt; Self {
        Self {
            embeddings: Mutex::new(HashMap::new()),
            responses: Mutex::new(HashMap::new()),
        }
    }
    
    pub fn get_embedding(&amp;self, text: &amp;str) -&gt; Option&lt;Vec&lt;f32&gt;&gt; {
        self.embeddings.lock().unwrap().get(text).cloned()
    }
    
    pub fn set_embedding(&amp;self, text: String, embedding: Vec&lt;f32&gt;) {
        self.embeddings.lock().unwrap().insert(text, embedding);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="logging-configuration"><a class="header" href="#logging-configuration">Logging Configuration</a></h2>
<h3 id="basic-logging"><a class="header" href="#basic-logging">Basic Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing_subscriber;

// Initialize logging
tracing_subscriber::fmt::init();

// Set log level via environment
// RUST_LOG=debug cargo run
<span class="boring">}</span></code></pre></pre>
<h3 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error, instrument};

#[instrument]
async fn process_document(content: &amp;str) -&gt; Result&lt;(), Error&gt; {
    info!(length = content.len(), "Processing document");
    
    // Process document...
    
    info!("Document processed successfully");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-configuration"><a class="header" href="#error-handling-configuration">Error Handling Configuration</a></h2>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("OpenAI API error: {0}")]
    OpenAI(#[from] ai_utils::error::Error),
    
    #[error("Configuration error: {0}")]
    Config(String),
    
    #[error("Rate limit exceeded")]
    RateLimit,
}

// Use in your application
async fn process_with_retry() -&gt; Result&lt;(), AppError&gt; {
    // Implementation with retry logic
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="retry-configuration"><a class="header" href="#retry-configuration">Retry Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

async fn with_retry&lt;F, T, E&gt;(mut f: F, max_retries: usize) -&gt; Result&lt;T, E&gt;
where
    F: FnMut() -&gt; Result&lt;T, E&gt;,
    E: std::fmt::Debug,
{
    let mut attempts = 0;
    loop {
        match f() {
            Ok(result) =&gt; return Ok(result),
            Err(e) =&gt; {
                attempts += 1;
                if attempts &gt;= max_retries {
                    return Err(e);
                }
                
                let delay = Duration::from_secs(2_u64.pow(attempts as u32));
                sleep(delay).await;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-configuration"><a class="header" href="#security-configuration">Security Configuration</a></h2>
<h3 id="api-key-management"><a class="header" href="#api-key-management">API Key Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use environment variables (recommended)
let api_key = std::env::var("OPENAI_API_KEY")
    .expect("OPENAI_API_KEY must be set");

// Or use a secure key management service
let api_key = get_secret_from_vault("openai-api-key").await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use regex::Regex;

fn validate_input(input: &amp;str) -&gt; Result&lt;(), Error&gt; {
    // Check for malicious content
    let malicious_pattern = Regex::new(r"&lt;script|javascript:|data:text/html").unwrap();
    
    if malicious_pattern.is_match(input) {
        return Err(Error::InvalidInput("Potentially malicious input detected".into()));
    }
    
    // Check length limits
    if input.len() &gt; 10000 {
        return Err(Error::InvalidInput("Input too long".into()));
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="development-vs-production"><a class="header" href="#development-vs-production">Development vs Production</a></h2>
<h3 id="development-configuration"><a class="header" href="#development-configuration">Development Configuration</a></h3>
<pre><code class="language-bash"># .env.development
RUST_LOG=debug
RUST_BACKTRACE=1
OPENAI_API_KEY=sk-test-...
QDRANT_URL=http://localhost:6333
</code></pre>
<h3 id="production-configuration"><a class="header" href="#production-configuration">Production Configuration</a></h3>
<pre><code class="language-bash"># .env.production
RUST_LOG=warn
OPENAI_API_KEY=sk-prod-...
QDRANT_URL=https://production-qdrant.com
LANGFUSE_PUBLIC_KEY=prod-key
LANGFUSE_SECRET_KEY=prod-secret
</code></pre>
<h3 id="configuration-loading"><a class="header" href="#configuration-loading">Configuration Loading</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dotenv::dotenv;

fn load_config() {
    // Load environment-specific config
    let env = std::env::var("RUST_ENV").unwrap_or_else(|_| "development".to_string());
    
    match env.as_str() {
        "production" =&gt; dotenv::from_filename(".env.production").ok(),
        "staging" =&gt; dotenv::from_filename(".env.staging").ok(),
        _ =&gt; dotenv::from_filename(".env.development").ok(),
    };
}
<span class="boring">}</span></code></pre></pre>
<h2 id="monitoring-configuration"><a class="header" href="#monitoring-configuration">Monitoring Configuration</a></h2>
<h3 id="langfuse-integration"><a class="header" href="#langfuse-integration">Langfuse Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ai_utils::langfuse::LangfuseService;

let langfuse = LangfuseService::new().await?;

// Track operations
langfuse.trace("document-processing", |trace| {
    trace.span("embedding-generation", |span| {
        // Generate embeddings
        span.end();
    });
    trace.end();
}).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU64, Ordering};

#[derive(Default)]
struct Metrics {
    requests: AtomicU64,
    errors: AtomicU64,
    latency: AtomicU64,
}

impl Metrics {
    pub fn increment_requests(&amp;self) {
        self.requests.fetch_add(1, Ordering::Relaxed);
    }
    
    pub fn record_latency(&amp;self, duration: Duration) {
        self.latency.store(duration.as_millis() as u64, Ordering::Relaxed);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-environment-management"><a class="header" href="#1-environment-management">1. Environment Management</a></h3>
<ul>
<li>Never commit API keys to version control</li>
<li>Use different keys for development and production</li>
<li>Rotate keys regularly</li>
</ul>
<h3 id="2-performance-tuning"><a class="header" href="#2-performance-tuning">2. Performance Tuning</a></h3>
<ul>
<li>Monitor API usage and costs</li>
<li>Implement appropriate caching strategies</li>
<li>Use batch operations when possible</li>
</ul>
<h3 id="3-error-handling-1"><a class="header" href="#3-error-handling-1">3. Error Handling</a></h3>
<ul>
<li>Implement comprehensive error handling</li>
<li>Use structured logging for debugging</li>
<li>Set up monitoring and alerting</li>
</ul>
<h3 id="4-security"><a class="header" href="#4-security">4. Security</a></h3>
<ul>
<li>Validate all inputs</li>
<li>Use HTTPS for all external communications</li>
<li>Implement rate limiting</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-overview"><a class="header" href="#modules-overview">Modules Overview</a></h1>
<p>AI Utils is organized into several core modules, each providing a set of capabilities for building AI agents. Here's a high-level overview of each module:</p>
<hr />
<h2 id="openai"><a class="header" href="#openai">OpenAI</a></h2>
<ul>
<li><strong>Description:</strong> Integration with OpenAI's API for chat completions, embeddings, image generation, and audio transcription.</li>
<li><strong>Key Features:</strong>
<ul>
<li>Chat and conversation handling</li>
<li>Embedding generation for semantic search</li>
<li>Image generation (DALL-E)</li>
<li>Audio transcription (Whisper)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="qdrant"><a class="header" href="#qdrant">Qdrant</a></h2>
<ul>
<li><strong>Description:</strong> Vector database integration for high-performance vector storage and similarity search.</li>
<li><strong>Key Features:</strong>
<ul>
<li>Collection management</li>
<li>Upsert/search vectors</li>
<li>Store and retrieve metadata</li>
</ul>
</li>
</ul>
<hr />
<h2 id="text-splitter-1"><a class="header" href="#text-splitter-1">Text Splitter</a></h2>
<ul>
<li><strong>Description:</strong> Advanced text chunking and tokenization for processing large documents.</li>
<li><strong>Key Features:</strong>
<ul>
<li>Token-aware splitting</li>
<li>Configurable chunk sizes and overlap</li>
<li>Metadata preservation</li>
</ul>
</li>
</ul>
<hr />
<h2 id="langfuse"><a class="header" href="#langfuse">Langfuse</a></h2>
<ul>
<li><strong>Description:</strong> Monitoring and observability for AI applications.</li>
<li><strong>Key Features:</strong>
<ul>
<li>Trace and span tracking</li>
<li>Performance and error monitoring</li>
</ul>
</li>
</ul>
<hr />
<h2 id="common-utilities"><a class="header" href="#common-utilities">Common Utilities</a></h2>
<ul>
<li><strong>Description:</strong> Shared utilities and types used across all modules.</li>
<li><strong>Key Features:</strong>
<ul>
<li>Error handling</li>
<li>Base64/image processing</li>
<li>Common data types</li>
</ul>
</li>
</ul>
<hr />
<p>For detailed usage and examples, see the <a href="modules/../getting-started/quick-start.html">Quick Start</a> section.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="docs/scripts/mermaid.min.js"></script>
        <script src="docs/scripts/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
