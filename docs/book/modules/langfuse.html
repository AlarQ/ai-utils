<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Langfuse</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="langfuse-module"><a class="header" href="#langfuse-module">Langfuse Module</a></h1>
<p>The Langfuse module provides comprehensive monitoring and observability for AI applications through integration with the Langfuse platform. It enables tracking of traces, spans, generations, scores, and other observability events to monitor AI application performance and behavior.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Langfuse is an open-source LLM observability platform that helps you monitor, debug, and improve your LLM applications. This module provides a Rust client that implements the Langfuse ingestion API, allowing you to:</p>
<ul>
<li>Track complete AI workflows (traces)</li>
<li>Monitor individual operations (spans)</li>
<li>Record model outputs (generations)</li>
<li>Evaluate performance with scores</li>
<li>Log custom events and observations</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The module uses environment variables for configuration:</p>
<pre><code class="language-bash">LANGFUSE_PUBLIC_KEY=your_public_key
LANGFUSE_SECRET_KEY=your_secret_key
LANGFUSE_HOST=https://cloud.langfuse.com  # Optional, defaults to cloud
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ai_utils::langfuse::{LangfuseConfig, LangfuseServiceImpl};

let config = LangfuseConfig::new();
let service = LangfuseServiceImpl::new(config);
<span class="boring">}</span></code></pre></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="traces"><a class="header" href="#traces">Traces</a></h3>
<p>A trace represents a complete AI workflow or session. It's the top-level container that groups related operations together.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use uuid::Uuid;
use ai_utils::openai::OpenAIMessage;

let trace_id = Uuid::new_v4();
let input_messages = vec![OpenAIMessage::new("user", "Hello", None)];
let output_messages = vec![OpenAIMessage::new("assistant", "Hi there!", None)];

let trace_id_str = service
    .create_trace(
        trace_id,
        "chat_conversation",
        Some(&amp;input_messages),
        Some(&amp;output_messages),
        Some("conversation_123"),
    )
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="generations"><a class="header" href="#generations">Generations</a></h3>
<p>A generation represents a single model output (e.g., an LLM call) within a trace. It tracks input, output, model parameters, and usage statistics.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a generation
let generation_id = service
    .create_generation(
        &amp;trace_id_str,
        "gpt_response",
        "gpt-4",
        &amp;input_messages,
    )
    .await?;

// Update with output
let completion = ChatCompletion {
    choices: vec![Choice {
        message: Message::assistant("The answer is 42".to_string()),
    }],
    model: "gpt-4".to_string(),
    usage: Some(Usage {
        prompt_tokens: 10,
        completion_tokens: 5,
        total_tokens: 15,
    }),
};

service.update_generation(&amp;generation_id, &amp;completion).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="spans"><a class="header" href="#spans">Spans</a></h3>
<p>Spans represent individual operations or steps within a trace. They can be used to track custom logic, API calls, or any measurable operation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a span
let span_id = service
    .create_span(
        &amp;trace_id_str,
        "data_processing",
        Some(&amp;input_messages),
    )
    .await?;

// Update with results
let output_messages = vec![OpenAIMessage::new("system", "Processed", None)];
service.update_span(&amp;span_id, &amp;output_messages).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="scores"><a class="header" href="#scores">Scores</a></h3>
<p>Scores are quantitative or qualitative evaluations attached to traces or observations. They're useful for tracking performance metrics or user feedback.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ai_utils::langfuse::types::{ScoreBody, BaseEvent, IngestionEvent};

let score_body = ScoreBody {
    id: Some(Uuid::new_v4().to_string()),
    traceId: Some(trace_id_str.clone()),
    name: "accuracy".to_string(),
    value: json!(0.95),
    comment: Some("High accuracy score".to_string()),
    ..Default::default()
};

let base_event = BaseEvent {
    id: Uuid::new_v4().to_string(),
    timestamp: chrono::Utc::now().to_rfc3339(),
    metadata: None,
};

let event = IngestionEvent::score_create(base_event, score_body);
let batch = IngestionBatch {
    batch: vec![event],
    metadata: None,
};

service.send_batch(batch).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="event-types"><a class="header" href="#event-types">Event Types</a></h2>
<p>The module supports all Langfuse ingestion event types:</p>
<h3 id="core-events"><a class="header" href="#core-events">Core Events</a></h3>
<ul>
<li><strong>trace-create</strong>: Create a new trace</li>
<li><strong>span-create</strong>: Create a new span</li>
<li><strong>span-update</strong>: Update an existing span</li>
<li><strong>generation-create</strong>: Create a new generation</li>
<li><strong>generation-update</strong>: Update an existing generation</li>
</ul>
<h3 id="evaluation-events"><a class="header" href="#evaluation-events">Evaluation Events</a></h3>
<ul>
<li><strong>score-create</strong>: Create a score for evaluation</li>
</ul>
<h3 id="custom-events"><a class="header" href="#custom-events">Custom Events</a></h3>
<ul>
<li><strong>event-create</strong>: Create a custom event</li>
<li><strong>sdk-log</strong>: Log SDK-specific information</li>
<li><strong>observation-create</strong>: Create an observation</li>
<li><strong>observation-update</strong>: Update an observation</li>
</ul>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<h3 id="baseevent"><a class="header" href="#baseevent">BaseEvent</a></h3>
<p>Common fields for all events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BaseEvent {
    pub id: String,
    pub timestamp: String,
    pub metadata: Option&lt;serde_json::Value&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tracebody"><a class="header" href="#tracebody">TraceBody</a></h3>
<p>Trace-specific data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TraceBody {
    pub id: Option&lt;String&gt;,
    pub name: Option&lt;String&gt;,
    pub input: Option&lt;serde_json::Value&gt;,
    pub output: Option&lt;serde_json::Value&gt;,
    pub sessionId: Option&lt;String&gt;,
    pub metadata: Option&lt;serde_json::Value&gt;,
    // ... other optional fields
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generationcreatebody"><a class="header" href="#generationcreatebody">GenerationCreateBody</a></h3>
<p>Generation creation data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GenerationCreateBody {
    pub span: SpanCreateBody,  // Flattened span data
    pub model: Option&lt;String&gt;,
    pub modelParameters: Option&lt;serde_json::Value&gt;,
    pub usage: Option&lt;IngestionUsage&gt;,
    // ... other optional fields
}
<span class="boring">}</span></code></pre></pre>
<h3 id="scorebody"><a class="header" href="#scorebody">ScoreBody</a></h3>
<p>Score evaluation data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ScoreBody {
    pub name: String,
    pub value: serde_json::Value,
    pub traceId: Option&lt;String&gt;,
    pub observationId: Option&lt;String&gt;,
    pub comment: Option&lt;String&gt;,
    // ... other optional fields
}
<span class="boring">}</span></code></pre></pre>
<h2 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h2>
<p>The module supports batch ingestion for efficient event processing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ai_utils::langfuse::types::{IngestionBatch, IngestionEvent};

let events = vec![
    IngestionEvent::trace_create(base_event1, trace_body),
    IngestionEvent::generation_create(base_event2, generation_body),
    IngestionEvent::score_create(base_event3, score_body),
];

let batch = IngestionBatch {
    batch: events,
    metadata: Some(json!({"source": "ai_utils"})),
};

let response = service.send_batch(batch).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The module provides detailed error handling for batch operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match service.send_batch(batch).await {
    Ok(response) =&gt; {
        println!("Successes: {}", response.successes.len());
        println!("Errors: {}", response.errors.len());
        
        for error in &amp;response.errors {
            eprintln!("Error ID {}: {} (status: {})", 
                error.id, 
                error.message.as_deref().unwrap_or("Unknown"), 
                error.status
            );
        }
    }
    Err(e) =&gt; eprintln!("Batch failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="helper-methods"><a class="header" href="#helper-methods">Helper Methods</a></h2>
<p>The module provides helper methods for creating properly typed events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create events with proper type fields
let trace_event = IngestionEvent::trace_create(base_event, trace_body);
let generation_event = IngestionEvent::generation_create(base_event, generation_body);
let score_event = IngestionEvent::score_create(base_event, score_body);
let span_event = IngestionEvent::span_create(base_event, span_body);
<span class="boring">}</span></code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The module includes comprehensive tests that demonstrate usage patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_create_trace() {
    let config = LangfuseConfig::new();
    let service = LangfuseServiceImpl::new(config);
    
    let trace_id = Uuid::new_v4();
    let result = service
        .create_trace(trace_id, "test_trace", None, None, None)
        .await;
    
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="chat-application-monitoring"><a class="header" href="#chat-application-monitoring">Chat Application Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_chat_message(
    service: &amp;LangfuseServiceImpl,
    user_message: &amp;str,
) -&gt; Result&lt;String, Error&gt; {
    let trace_id = Uuid::new_v4();
    
    // Create trace
    let trace_id_str = service
        .create_trace(
            trace_id,
            "chat_interaction",
            Some(&amp;[OpenAIMessage::new("user", user_message, None)]),
            None,
            None,
        )
        .await?;
    
    // Create generation
    let generation_id = service
        .create_generation(
            &amp;trace_id_str,
            "gpt_response",
            "gpt-4",
            &amp;[OpenAIMessage::new("user", user_message, None)],
        )
        .await?;
    
    // Get response from OpenAI
    let completion = openai_client.chat_completion(/* ... */).await?;
    
    // Update generation with response
    service.update_generation(&amp;generation_id, &amp;completion).await?;
    
    // Create score for response quality
    let score_body = ScoreBody {
        name: "response_quality".to_string(),
        value: json!(0.8),
        traceId: Some(trace_id_str),
        ..Default::default()
    };
    
    let batch = IngestionBatch {
        batch: vec![IngestionEvent::score_create(
            BaseEvent {
                id: Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().to_rfc3339(),
                metadata: None,
            },
            score_body,
        )],
        metadata: None,
    };
    
    service.send_batch(batch).await?;
    
    Ok(completion.choices[0].message.content.clone())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="workflow-monitoring"><a class="header" href="#workflow-monitoring">Workflow Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn monitor_workflow(
    service: &amp;LangfuseServiceImpl,
    workflow_name: &amp;str,
) -&gt; Result&lt;(), Error&gt; {
    let trace_id = Uuid::new_v4();
    let trace_id_str = service
        .create_trace(trace_id, workflow_name, None, None, None)
        .await?;
    
    // Monitor data preprocessing
    let preprocess_span = service
        .create_span(&amp;trace_id_str, "data_preprocessing", None)
        .await?;
    
    // ... perform preprocessing ...
    
    service.update_span(&amp;preprocess_span, &amp;[/* results */]).await?;
    
    // Monitor model inference
    let generation_id = service
        .create_generation(&amp;trace_id_str, "model_inference", "gpt-4", &amp;[/* input */])
        .await?;
    
    // ... perform inference ...
    
    service.update_generation(&amp;generation_id, &amp;completion).await?;
    
    // Add performance score
    let score_body = ScoreBody {
        name: "workflow_performance".to_string(),
        value: json!(0.95),
        traceId: Some(trace_id_str),
        ..Default::default()
    };
    
    let batch = IngestionBatch {
        batch: vec![IngestionEvent::score_create(
            BaseEvent {
                id: Uuid::new_v4().to_string(),
                timestamp: chrono::Utc::now().to_rfc3339(),
                metadata: None,
            },
            score_body,
        )],
        metadata: None,
    };
    
    service.send_batch(batch).await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use meaningful names</strong>: Give traces, spans, and generations descriptive names for better observability.</p>
</li>
<li>
<p><strong>Include metadata</strong>: Add relevant metadata to help with debugging and analysis.</p>
</li>
<li>
<p><strong>Batch operations</strong>: Use batch ingestion for multiple events to improve performance.</p>
</li>
<li>
<p><strong>Error handling</strong>: Always check batch responses for individual event failures.</p>
</li>
<li>
<p><strong>Consistent IDs</strong>: Use consistent ID patterns across your application for easier correlation.</p>
</li>
<li>
<p><strong>Environment separation</strong>: Use different Langfuse projects for development, staging, and production.</p>
</li>
</ol>
<h2 id="current-implementation-status"><a class="header" href="#current-implementation-status">Current Implementation Status</a></h2>
<p>The module currently supports:</p>
<p>‚úÖ <strong>Core Features</strong></p>
<ul>
<li>Trace creation and management</li>
<li>Generation creation and updates</li>
<li>Span creation and updates</li>
<li>Score creation</li>
<li>Batch ingestion with detailed error handling</li>
<li>All Langfuse event types</li>
</ul>
<p>‚úÖ <strong>Type Safety</strong></p>
<ul>
<li>Proper Rust types matching Langfuse API spec</li>
<li>Helper methods for event creation</li>
<li>Comprehensive error handling</li>
</ul>
<p>‚úÖ <strong>Testing</strong></p>
<ul>
<li>Integration tests for core functionality</li>
<li>Environment-aware test skipping</li>
</ul>
<p>üîÑ <strong>Future Enhancements</strong></p>
<ul>
<li>Additional helper methods for all event types</li>
<li>More comprehensive documentation</li>
<li>Advanced observability features</li>
<li>Performance optimizations</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../modules/overview.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../modules/overview.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
